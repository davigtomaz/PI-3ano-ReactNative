{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport React, { PureComponent } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport PropTypes from 'prop-types';\nimport Svg from 'react-native-svg';\nimport * as array from 'd3-array';\nimport * as scale from 'd3-scale';\nimport * as shape from 'd3-shape';\nimport Path from \"../animated-path\";\nvar StackedBarGrouped = function (_PureComponent) {\n  _inherits(StackedBarGrouped, _PureComponent);\n  var _super = _createSuper(StackedBarGrouped);\n  function StackedBarGrouped() {\n    var _this;\n    _classCallCheck(this, StackedBarGrouped);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      width: 0,\n      height: 0\n    });\n    _defineProperty(_assertThisInitialized(_this), \"coordinatesToPathCommands\", function (x0, y0, x1, y1, borderRadius, showTopBorder, showBottomBorder) {\n      var commands = [];\n      commands.push({\n        marker: 'M',\n        values: [x0, y0]\n      });\n      if (showTopBorder) {\n        var topLeft1 = [x0 + borderRadius, y0];\n        var topLeft2 = [x0, y0 + borderRadius];\n        commands.push({\n          marker: 'L',\n          values: topLeft1\n        });\n        commands.push({\n          marker: 'C',\n          values: [].concat(topLeft1, [x0, y0], topLeft2)\n        });\n        commands.push({\n          marker: 'L',\n          values: topLeft2\n        });\n      } else {\n        commands.push({\n          marker: 'L',\n          values: [x0, y0]\n        });\n      }\n      if (showBottomBorder) {\n        var bottomLeft1 = [x0, y1 - borderRadius];\n        var bottomLeft2 = [x0 + borderRadius, y1];\n        commands.push({\n          marker: 'L',\n          values: bottomLeft1\n        });\n        commands.push({\n          marker: 'C',\n          values: [].concat(bottomLeft1, [x0, y1], bottomLeft2)\n        });\n        commands.push({\n          marker: 'L',\n          values: bottomLeft2\n        });\n        var bottomRight1 = [x1 - borderRadius, y1];\n        var bottomRight2 = [x1, y1 - borderRadius];\n        commands.push({\n          marker: 'L',\n          values: bottomRight1\n        });\n        commands.push({\n          marker: 'C',\n          values: [].concat(bottomRight1, [x1, y1], bottomRight2)\n        });\n        commands.push({\n          marker: 'L',\n          values: bottomRight2\n        });\n      } else {\n        commands.push({\n          marker: 'L',\n          values: [x0, y1]\n        });\n        commands.push({\n          marker: 'L',\n          values: [x1, y1]\n        });\n      }\n      if (showTopBorder) {\n        var topRight1 = [x1, y0 + borderRadius];\n        var topRight2 = [x1 - borderRadius, y0];\n        commands.push({\n          marker: 'L',\n          values: topRight1\n        });\n        commands.push({\n          marker: 'C',\n          values: [].concat(topRight1, [x1, y0], topRight2)\n        });\n        commands.push({\n          marker: 'L',\n          values: topRight2\n        });\n      } else {\n        commands.push({\n          marker: 'L',\n          values: [x1, y0]\n        });\n      }\n      commands.push({\n        marker: 'Z',\n        values: []\n      });\n      return commands;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"commandsToSvgPath\", function (commands) {\n      return commands.map(function (command) {\n        return \"\".concat(command.marker, \" \").concat(command.values.join(','));\n      }).join(' ').trim();\n    });\n    return _this;\n  }\n  _createClass(StackedBarGrouped, [{\n    key: \"_onLayout\",\n    value: function _onLayout(event) {\n      var _event$nativeEvent$la = event.nativeEvent.layout,\n        height = _event$nativeEvent$la.height,\n        width = _event$nativeEvent$la.width;\n      this.setState({\n        height: height,\n        width: width\n      });\n    }\n  }, {\n    key: \"calcXScale\",\n    value: function calcXScale(domain) {\n      var _this$props = this.props,\n        horizontal = _this$props.horizontal,\n        _this$props$contentIn = _this$props.contentInset,\n        _this$props$contentIn2 = _this$props$contentIn.left,\n        left = _this$props$contentIn2 === void 0 ? 0 : _this$props$contentIn2,\n        _this$props$contentIn3 = _this$props$contentIn.right,\n        right = _this$props$contentIn3 === void 0 ? 0 : _this$props$contentIn3,\n        spacingInner = _this$props.spacingInner,\n        spacingOuter = _this$props.spacingOuter;\n      var width = this.state.width;\n      if (horizontal) {\n        return scale.scaleLinear().domain(domain).range([left, width - right]);\n      }\n      return scale.scaleBand().domain(domain).range([left, width - right]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n    }\n  }, {\n    key: \"calcYScale\",\n    value: function calcYScale(domain) {\n      var _this$props2 = this.props,\n        horizontal = _this$props2.horizontal,\n        _this$props2$contentI = _this$props2.contentInset,\n        _this$props2$contentI2 = _this$props2$contentI.top,\n        top = _this$props2$contentI2 === void 0 ? 0 : _this$props2$contentI2,\n        _this$props2$contentI3 = _this$props2$contentI.bottom,\n        bottom = _this$props2$contentI3 === void 0 ? 0 : _this$props2$contentI3,\n        spacingInner = _this$props2.spacingInner,\n        spacingOuter = _this$props2.spacingOuter;\n      var height = this.state.height;\n      if (horizontal) {\n        return scale.scaleBand().domain(domain).range([top, height - bottom]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n      }\n      return scale.scaleLinear().domain(domain).range([height - bottom, top]);\n    }\n  }, {\n    key: \"calcAreas\",\n    value: function calcAreas(x, y, series) {\n      var _this2 = this;\n      var _this$props3 = this.props,\n        horizontal = _this$props3.horizontal,\n        colors = _this$props3.colors,\n        keys = _this$props3.keys,\n        data = _this$props3.data,\n        initialBorderRadius = _this$props3.borderRadius,\n        innerBarSpace = _this$props3.innerBarSpace;\n      var areas;\n      var barWidth;\n      if (horizontal) {\n        barWidth = y.bandwidth() / data.length;\n        areas = series.map(function (stack, stackIndex) {\n          return stack.map(function (serie, keyIndex) {\n            return serie.map(function (entry, entryIndex) {\n              var leftMargin = series.length > 1 ? innerBarSpace / 2 : 0;\n              var path = shape.area().x0(function (d) {\n                return x(d[0]);\n              }).x1(function (d) {\n                return x(d[1]);\n              }).y(function (d, _index) {\n                return (_index === 0 ? y(entryIndex) + barWidth * stackIndex + leftMargin : y(entryIndex) + barWidth + barWidth * stackIndex) - leftMargin;\n              }).defined(function (d) {\n                return !isNaN(d[0]) && !isNaN(d[1]);\n              })([entry, entry]);\n              return {\n                path: path,\n                color: colors[stackIndex][keyIndex],\n                key: keys[stackIndex][keyIndex]\n              };\n            });\n          });\n        });\n      } else {\n        barWidth = x.bandwidth() / data.length;\n        areas = series.map(function (stack, stackIndex) {\n          return stack.map(function (serie, keyIndex) {\n            return serie.map(function (entry, entryIndex) {\n              var leftMargin = series.length > 1 ? innerBarSpace / 2 : 0;\n              var x0 = x(entryIndex) + barWidth * stackIndex + leftMargin;\n              var x1 = x(entryIndex) + barWidth + barWidth * stackIndex - leftMargin;\n              var y0 = y(entry[1]);\n              var y1 = y(entry[0]);\n              var barHeight = y1 - y0;\n              var borderRadius = initialBorderRadius * 2 > barHeight ? barHeight / 2 : initialBorderRadius;\n              var showTopBorder = keyIndex === stack.length - 1;\n              var showBottomBorder = keyIndex === 0;\n              var commands = _this2.coordinatesToPathCommands(x0, y0, x1, y1, borderRadius, showTopBorder, showBottomBorder);\n              return {\n                path: _this2.commandsToSvgPath(commands),\n                color: colors[stackIndex][keyIndex],\n                key: keys[stackIndex][keyIndex]\n              };\n            });\n          });\n        });\n      }\n      return array.merge(areas);\n    }\n  }, {\n    key: \"calcExtent\",\n    value: function calcExtent(values) {\n      var _this$props4 = this.props,\n        gridMax = _this$props4.gridMax,\n        gridMin = _this$props4.gridMin;\n      var mergedValues = array.merge(values);\n      return array.extent([].concat(_toConsumableArray(mergedValues), [gridMin, gridMax]));\n    }\n  }, {\n    key: \"calcIndexes\",\n    value: function calcIndexes() {\n      var data = this.props.data;\n      return data[0].data.map(function (_, index) {\n        return index;\n      });\n    }\n  }, {\n    key: \"getSeries\",\n    value: function getSeries() {\n      var _this$props5 = this.props,\n        data = _this$props5.data,\n        keys = _this$props5.keys,\n        offset = _this$props5.offset,\n        order = _this$props5.order,\n        valueAccessor = _this$props5.valueAccessor;\n      return data.map(function (obj, index) {\n        return shape.stack().keys(keys[index]).value(function (item, key) {\n          return valueAccessor({\n            item: item,\n            key: key\n          });\n        }).order(order).offset(offset)(obj.data);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n      var _this$props6 = this.props,\n        data = _this$props6.data,\n        animate = _this$props6.animate,\n        animationDuration = _this$props6.animationDuration,\n        style = _this$props6.style,\n        numberOfTicks = _this$props6.numberOfTicks,\n        children = _this$props6.children,\n        horizontal = _this$props6.horizontal;\n      var _this$state = this.state,\n        height = _this$state.height,\n        width = _this$state.width;\n      if (data.length === 0) {\n        return React.createElement(View, {\n          style: style\n        });\n      }\n      var series = this.getSeries();\n      var values = array.merge(array.merge(series));\n      var indexes = this.calcIndexes(values);\n      var extent = this.calcExtent(values);\n      var ticks = array.ticks(extent[0], extent[1], numberOfTicks);\n      var xDomain = horizontal ? extent : indexes;\n      var yDomain = horizontal ? indexes : extent;\n      var x = this.calcXScale(xDomain);\n      var y = this.calcYScale(yDomain);\n      var bandwidth = horizontal ? y.bandwidth() : x.bandwidth();\n      var stacks = this.calcAreas(x, y, series);\n      var extraProps = {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        ticks: ticks,\n        data: data,\n        bandwidth: bandwidth\n      };\n      return React.createElement(View, {\n        style: style\n      }, React.createElement(View, {\n        style: {\n          flex: 1\n        },\n        onLayout: function onLayout(event) {\n          return _this3._onLayout(event);\n        }\n      }, height > 0 && width > 0 && React.createElement(Svg, {\n        style: {\n          height: height,\n          width: width\n        }\n      }, React.Children.map(children, function (child) {\n        if (child && child.props.belowChart) {\n          return React.cloneElement(child, extraProps);\n        }\n        return null;\n      }), stacks.map(function (areas, indexStack) {\n        var areaIndex = indexStack % data.length;\n        return areas.map(function (bar, indexArea) {\n          var keyIndex = indexArea % data[areaIndex].data.length;\n          var key = \"\".concat(areaIndex, \"-\").concat(keyIndex, \"-\").concat(bar.key);\n          var svg = data[areaIndex].data[keyIndex][bar.key].svg;\n          return React.createElement(Path, _extends({\n            key: key,\n            fill: bar.color\n          }, svg, {\n            d: bar.path,\n            animate: animate,\n            animationDuration: animationDuration\n          }));\n        });\n      }), React.Children.map(children, function (child) {\n        if (child && !child.props.belowChart) {\n          return React.cloneElement(child, extraProps);\n        }\n        return null;\n      }))));\n    }\n  }]);\n  return StackedBarGrouped;\n}(PureComponent);\nStackedBarGrouped.propTypes = {\n  data: PropTypes.arrayOf(PropTypes.object),\n  keys: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n  colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n  offset: PropTypes.func,\n  order: PropTypes.func,\n  style: PropTypes.any,\n  spacingInner: PropTypes.number,\n  spacingOuter: PropTypes.number,\n  animate: PropTypes.bool,\n  animationDuration: PropTypes.number,\n  contentInset: PropTypes.shape({\n    top: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    bottom: PropTypes.number\n  }),\n  gridMin: PropTypes.number,\n  gridMax: PropTypes.number,\n  valueAccessor: PropTypes.func,\n  borderRadius: PropTypes.number,\n  innerBarSpace: PropTypes.number\n};\nStackedBarGrouped.defaultProps = {\n  spacingInner: 0.05,\n  spacingOuter: 0.05,\n  offset: shape.stackOffsetNone,\n  order: shape.stackOrderNone,\n  width: 100,\n  height: 100,\n  showZeroAxis: true,\n  contentInset: {},\n  numberOfTicks: 10,\n  showGrid: true,\n  valueAccessor: function valueAccessor(_ref) {\n    var item = _ref.item,\n      key = _ref.key;\n    return item[key];\n  },\n  borderRadius: 0,\n  innerBarSpace: 0\n};\nexport default StackedBarGrouped;","map":{"version":3,"names":["React","PureComponent","View","PropTypes","Svg","array","scale","shape","Path","StackedBarGrouped","_PureComponent","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","width","height","x0","y0","x1","y1","borderRadius","showTopBorder","showBottomBorder","commands","push","marker","values","topLeft1","topLeft2","bottomLeft1","bottomLeft2","bottomRight1","bottomRight2","topRight1","topRight2","map","command","join","trim","_createClass","key","value","_onLayout","event","_event$nativeEvent$la","nativeEvent","layout","setState","calcXScale","domain","_this$props","props","horizontal","_this$props$contentIn","contentInset","_this$props$contentIn2","left","_this$props$contentIn3","right","spacingInner","spacingOuter","state","scaleLinear","range","scaleBand","paddingInner","paddingOuter","calcYScale","_this$props2","_this$props2$contentI","_this$props2$contentI2","top","_this$props2$contentI3","bottom","calcAreas","x","y","series","_this2","_this$props3","colors","keys","data","initialBorderRadius","innerBarSpace","areas","barWidth","bandwidth","stack","stackIndex","serie","keyIndex","entry","entryIndex","leftMargin","path","area","d","_index","defined","isNaN","color","barHeight","coordinatesToPathCommands","commandsToSvgPath","merge","calcExtent","_this$props4","gridMax","gridMin","mergedValues","extent","_toConsumableArray","calcIndexes","_","index","getSeries","_this$props5","offset","order","valueAccessor","obj","item","render","_this3","_this$props6","animate","animationDuration","style","numberOfTicks","children","_this$state","createElement","indexes","ticks","xDomain","yDomain","stacks","extraProps","flex","onLayout","Children","child","belowChart","cloneElement","indexStack","areaIndex","bar","indexArea","svg","_extends","fill","propTypes","arrayOf","object","string","isRequired","func","any","number","bool","defaultProps","stackOffsetNone","stackOrderNone","showZeroAxis","showGrid","_ref"],"sources":["/home/davigtomaz/PI-3ano-ReactNative/node_modules/react-native-svg-charts/lib/module/stacked-bar-chart/stacked-bar-grouped.js"],"sourcesContent":["import React, { PureComponent } from 'react'\nimport { View } from 'react-native'\nimport PropTypes from 'prop-types'\nimport Svg from 'react-native-svg'\nimport * as array from 'd3-array'\nimport * as scale from 'd3-scale'\nimport * as shape from 'd3-shape'\nimport Path from '../animated-path'\n\nclass StackedBarGrouped extends PureComponent {\n    state = {\n        width: 0,\n        height: 0,\n    }\n\n    _onLayout(event) {\n        const {\n            nativeEvent: {\n                layout: { height, width },\n            },\n        } = event\n        this.setState({ height, width })\n    }\n\n    calcXScale(domain) {\n        const {\n            horizontal,\n            contentInset: { left = 0, right = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { width } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleLinear()\n                .domain(domain)\n                .range([left, width - right])\n        }\n\n        return scale\n            .scaleBand()\n            .domain(domain)\n            .range([left, width - right])\n            .paddingInner([spacingInner])\n            .paddingOuter([spacingOuter])\n    }\n\n    calcYScale(domain) {\n        const {\n            horizontal,\n            contentInset: { top = 0, bottom = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { height } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleBand()\n                .domain(domain)\n                .range([top, height - bottom])\n                .paddingInner([spacingInner])\n                .paddingOuter([spacingOuter])\n        }\n\n        return scale\n            .scaleLinear()\n            .domain(domain)\n            .range([height - bottom, top])\n    }\n\n    calcAreas(x, y, series) {\n        const { horizontal, colors, keys, data, borderRadius: initialBorderRadius, innerBarSpace } = this.props\n        let areas\n        let barWidth\n\n        if (horizontal) {\n            barWidth = y.bandwidth() / data.length\n\n            areas = series.map((stack, stackIndex) => {\n                return stack.map((serie, keyIndex) => {\n                    return serie.map((entry, entryIndex) => {\n                        const leftMargin = series.length > 1 ? innerBarSpace / 2 : 0\n\n                        const path = shape\n                            .area()\n                            .x0((d) => x(d[0]))\n                            .x1((d) => x(d[1]))\n                            .y(\n                                (d, _index) =>\n                                    (_index === 0\n                                        ? y(entryIndex) + barWidth * stackIndex + leftMargin\n                                        : y(entryIndex) + barWidth + barWidth * stackIndex) - leftMargin\n                            )\n                            .defined((d) => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry])\n\n                        return {\n                            path,\n                            color: colors[stackIndex][keyIndex],\n                            key: keys[stackIndex][keyIndex],\n                        }\n                    })\n                })\n            })\n        } else {\n            barWidth = x.bandwidth() / data.length\n\n            areas = series.map((stack, stackIndex) => {\n                return stack.map((serie, keyIndex) => {\n                    return serie.map((entry, entryIndex) => {\n                        const leftMargin = series.length > 1 ? innerBarSpace / 2 : 0\n                        const x0 = x(entryIndex) + barWidth * stackIndex + leftMargin\n                        const x1 = x(entryIndex) + barWidth + barWidth * stackIndex - leftMargin\n                        const y0 = y(entry[1])\n                        const y1 = y(entry[0])\n                        const barHeight = y1 - y0\n                        const borderRadius = initialBorderRadius * 2 > barHeight ? barHeight / 2 : initialBorderRadius\n                        const showTopBorder = keyIndex === stack.length - 1\n                        const showBottomBorder = keyIndex === 0\n                        const commands = this.coordinatesToPathCommands(\n                            x0,\n                            y0,\n                            x1,\n                            y1,\n                            borderRadius,\n                            showTopBorder,\n                            showBottomBorder\n                        )\n\n                        return {\n                            path: this.commandsToSvgPath(commands),\n                            color: colors[stackIndex][keyIndex],\n                            key: keys[stackIndex][keyIndex],\n                        }\n                    })\n                })\n            })\n        }\n\n        return array.merge(areas)\n    }\n\n    coordinatesToPathCommands = (x0, y0, x1, y1, borderRadius, showTopBorder, showBottomBorder) => {\n        const commands = []\n        commands.push({ marker: 'M', values: [x0, y0] })\n\n        if (showTopBorder) {\n            const topLeft1 = [x0 + borderRadius, y0]\n            const topLeft2 = [x0, y0 + borderRadius]\n            commands.push({ marker: 'L', values: topLeft1 })\n            commands.push({\n                marker: 'C',\n                values: [...topLeft1, x0, y0, ...topLeft2],\n            })\n            commands.push({ marker: 'L', values: topLeft2 })\n        } else {\n            commands.push({ marker: 'L', values: [x0, y0] })\n        }\n\n        if (showBottomBorder) {\n            const bottomLeft1 = [x0, y1 - borderRadius]\n            const bottomLeft2 = [x0 + borderRadius, y1]\n            commands.push({ marker: 'L', values: bottomLeft1 })\n            commands.push({\n                marker: 'C',\n                values: [...bottomLeft1, x0, y1, ...bottomLeft2],\n            })\n            commands.push({ marker: 'L', values: bottomLeft2 })\n            const bottomRight1 = [x1 - borderRadius, y1]\n            const bottomRight2 = [x1, y1 - borderRadius]\n            commands.push({ marker: 'L', values: bottomRight1 })\n            commands.push({\n                marker: 'C',\n                values: [...bottomRight1, x1, y1, ...bottomRight2],\n            })\n            commands.push({ marker: 'L', values: bottomRight2 })\n        } else {\n            commands.push({ marker: 'L', values: [x0, y1] })\n            commands.push({ marker: 'L', values: [x1, y1] })\n        }\n\n        if (showTopBorder) {\n            const topRight1 = [x1, y0 + borderRadius]\n            const topRight2 = [x1 - borderRadius, y0]\n\n            commands.push({ marker: 'L', values: topRight1 })\n            commands.push({\n                marker: 'C',\n                values: [...topRight1, x1, y0, ...topRight2],\n            })\n            commands.push({ marker: 'L', values: topRight2 })\n        } else {\n            commands.push({ marker: 'L', values: [x1, y0] })\n        }\n\n        commands.push({ marker: 'Z', values: [] })\n\n        return commands\n    }\n\n    commandsToSvgPath = (commands) =>\n        commands\n            .map((command) => `${command.marker} ${command.values.join(',')}`)\n            .join(' ')\n            .trim()\n\n    calcExtent(values) {\n        const { gridMax, gridMin } = this.props\n\n        // One more merge for stacked groups\n        const mergedValues = array.merge(values)\n\n        return array.extent([...mergedValues, gridMin, gridMax])\n    }\n\n    calcIndexes() {\n        const { data } = this.props\n\n        // Must return an array with indexes for the number of groups to be shown\n        return data[0].data.map((_, index) => index)\n    }\n\n    getSeries() {\n        const { data, keys, offset, order, valueAccessor } = this.props\n\n        return data.map((obj, index) =>\n            shape\n                .stack()\n                .keys(keys[index])\n                .value((item, key) => valueAccessor({ item, key }))\n                .order(order)\n                .offset(offset)(obj.data)\n        )\n    }\n\n    render() {\n        const { data, animate, animationDuration, style, numberOfTicks, children, horizontal } = this.props\n\n        const { height, width } = this.state\n\n        if (data.length === 0) {\n            return <View style={style} />\n        }\n\n        const series = this.getSeries()\n\n        //double merge arrays to extract just the values\n        const values = array.merge(array.merge(series))\n        const indexes = this.calcIndexes(values)\n\n        const extent = this.calcExtent(values)\n        const ticks = array.ticks(extent[0], extent[1], numberOfTicks)\n\n        const xDomain = horizontal ? extent : indexes\n        const yDomain = horizontal ? indexes : extent\n\n        const x = this.calcXScale(xDomain)\n        const y = this.calcYScale(yDomain)\n\n        const bandwidth = horizontal ? y.bandwidth() : x.bandwidth()\n\n        const stacks = this.calcAreas(x, y, series)\n\n        const extraProps = {\n            x,\n            y,\n            width,\n            height,\n            ticks,\n            data,\n            bandwidth,\n        }\n\n        return (\n            <View style={style}>\n                <View style={{ flex: 1 }} onLayout={(event) => this._onLayout(event)}>\n                    {height > 0 && width > 0 && (\n                        <Svg style={{ height, width }}>\n                            {React.Children.map(children, (child) => {\n                                if (child && child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                            {stacks.map((areas, indexStack) => {\n                                const areaIndex = indexStack % data.length\n\n                                return areas.map((bar, indexArea) => {\n                                    const keyIndex = indexArea % data[areaIndex].data.length\n                                    const key = `${areaIndex}-${keyIndex}-${bar.key}`\n\n                                    const { svg } = data[areaIndex].data[keyIndex][bar.key]\n\n                                    return (\n                                        <Path\n                                            key={key}\n                                            fill={bar.color}\n                                            {...svg}\n                                            d={bar.path}\n                                            animate={animate}\n                                            animationDuration={animationDuration}\n                                        />\n                                    )\n                                })\n                            })}\n                            {React.Children.map(children, (child) => {\n                                if (child && !child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                        </Svg>\n                    )}\n                </View>\n            </View>\n        )\n    }\n}\n\nStackedBarGrouped.propTypes = {\n    data: PropTypes.arrayOf(PropTypes.object),\n    keys: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n    colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n    offset: PropTypes.func,\n    order: PropTypes.func,\n    style: PropTypes.any,\n    spacingInner: PropTypes.number,\n    spacingOuter: PropTypes.number,\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n    contentInset: PropTypes.shape({\n        top: PropTypes.number,\n        left: PropTypes.number,\n        right: PropTypes.number,\n        bottom: PropTypes.number,\n    }),\n    gridMin: PropTypes.number,\n    gridMax: PropTypes.number,\n    valueAccessor: PropTypes.func,\n    borderRadius: PropTypes.number,\n    innerBarSpace: PropTypes.number,\n}\n\nStackedBarGrouped.defaultProps = {\n    spacingInner: 0.05,\n    spacingOuter: 0.05,\n    offset: shape.stackOffsetNone,\n    order: shape.stackOrderNone,\n    width: 100,\n    height: 100,\n    showZeroAxis: true,\n    contentInset: {},\n    numberOfTicks: 10,\n    showGrid: true,\n    valueAccessor: ({ item, key }) => item[key],\n    borderRadius: 0,\n    innerBarSpace: 0,\n}\n\nexport default StackedBarGrouped\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}